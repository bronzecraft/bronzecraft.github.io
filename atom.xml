<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bronzecraft.github.io</id>
    <title>迷藏</title>
    <updated>2021-02-06T14:15:08.425Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bronzecraft.github.io"/>
    <link rel="self" href="https://bronzecraft.github.io/atom.xml"/>
    <subtitle>宇宙尽头的餐馆门口的保安</subtitle>
    <logo>https://bronzecraft.github.io/images/avatar.png</logo>
    <icon>https://bronzecraft.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 迷藏</rights>
    <entry>
        <title type="html"><![CDATA[python实现多线程写入和读出]]></title>
        <id>https://bronzecraft.github.io/post/Xs9mZGFXm/</id>
        <link href="https://bronzecraft.github.io/post/Xs9mZGFXm/">
        </link>
        <updated>2021-02-06T14:12:04.000Z</updated>
        <content type="html"><![CDATA[<p>   一个简单例子。代码如下：</p>
<pre><code># -*- coding: utf-8 -*-

import threading
import time
import queue
import os
import subprocess

class sharefunc:
    '''
    shared function
    '''
    def __init__(self,initial_value=0):
        # self.value = intial_value
        self.data=initial_value
        self._value_lock = threading.Lock()
        self.tasklist = []
    
    def taskin(self,data):
        for i in range(data):
            with self._value_lock:
                self.tasklist.append(i)
            time.sleep(1)
    
    def taskini(self,data):
        for i in range(data):
            with self._value_lock:
                self.tasklist.append(i+20)
            time.sleep(0.5)
     
        
     
        
    def taskout(self):
        with self._value_lock:
            f = open(&quot;run.bat&quot;,&quot;w&quot;)
            x = self.tasklist[0]
            del self.tasklist[0]
            print ('out number:',x)
            print ('lenth oflist is :',len(self.tasklist))
            # f.write('del *.txt' +&quot;\n&quot;)
            f.write(&quot;ping -n 1 www.bing.com &gt; &quot;+str(x)+&quot;.txt&quot; +&quot;\n&quot;)
            f.write(&quot;ping -n &quot;+str(x)+&quot; www.bing.com &gt;&gt; &quot;+str(x)+&quot;.txt&quot;+&quot;\n&quot;)           
            f.close()
        # print(&quot;1ok&quot;)
        os.system(&quot;run.bat&quot;)
        # print(&quot;2ok&quot;)
        return x
test=[]
t = sharefunc()
t.taskin(2)
# print(t.tasklist[0])
# x = t.taskout()
# print(x)
print(len(t.tasklist))
t1 = threading.Thread(target=t.taskin,args=(9,))
t1.start()
t3 = threading.Thread(target=t.taskini,args=(9,))
t3.start()

# t1.join()
# for i in range(10):
#     print(t1.is_alive())
#     if (not t1.is_alive()):
#         t1 = threading.Thread(target=t.taskin,args=(i+2,))
#         t1.start()
#         print(&quot;t1: &quot;,i)

tx = 1
# for i in t.tasklist:
#     print (i)
while (tx==1):
    # print(&quot;t.taskin thread is &quot;,t1.is_alive())
    if (len(t.tasklist)&gt;0):
        t2 = threading.Thread(target=t.taskout,args=())
        t2.start()
        t2.join()
    if (not t1.is_alive()) and (len(t.tasklist)&lt;1) and(not t1.is_alive()):
        break
        

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于太空漫游四部曲]]></title>
        <id>https://bronzecraft.github.io/post/qt-aecOEz/</id>
        <link href="https://bronzecraft.github.io/post/qt-aecOEz/">
        </link>
        <updated>2021-01-31T12:47:21.000Z</updated>
        <content type="html"><![CDATA[<p>  阿瑟克拉克“太空漫游四部曲”里，我最喜欢第二部。第一部探讨了人类可能的过去以及或许的未来，外星文明接近于神这个概念，整部小说可能哲学上的意义更浓一些。而第二部更进一步揭露外星文明的一角，特别是鲍曼和弗洛伊德见面那段，印象深刻，（至今还记得大卫鲍曼利用浮动的灰尘捏出来的人像只有眼睛最清晰，性别特征基本没有），算是对人类的未来有更深的描述。其后点燃木星这个桥段对于彼时的我来说更显瑰丽与宏大，整部小说在我理解范围内展示了外星技术的高度。后两部外星文明逐渐走下神坛，特别是最后一部，已经从神变成了普通高技术外星文明了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tkinter库学习笔记（1）]]></title>
        <id>https://bronzecraft.github.io/post/a-U-9nWgO/</id>
        <link href="https://bronzecraft.github.io/post/a-U-9nWgO/">
        </link>
        <updated>2021-01-31T11:10:54.000Z</updated>
        <content type="html"><![CDATA[<p>  周末简单看了下Tkinter库的帮助文档，写了一个小程序，记录鼠标点击按钮的次数，代码如下：</p>
<pre><code>import tkinter as tk

top = tk.Tk()
n = 0
def ph():
    global n
    n = n + 1
    lab.configure(text =str(n) )
    return 0
butn =tk.Button(top,text = &quot;click&quot;,command=ph)
lab = tk.Label(top,text = str(n))
lab.pack()
butn.pack()
top.mainloop()
</code></pre>
<p>  原打算使用bind方法实现的，不过暂时没搞懂bind的用法，一直失败。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无题]]></title>
        <id>https://bronzecraft.github.io/post/O-4HYtF7e/</id>
        <link href="https://bronzecraft.github.io/post/O-4HYtF7e/">
        </link>
        <updated>2021-01-25T12:33:50.000Z</updated>
        <content type="html"><![CDATA[<p>  惯于长夜过春时，挈妇将雏鬓有丝。<br>
  忍看朋辈成新鬼，怒向刀丛觅小诗。<br>
  梦里依稀慈母泪，城头变幻大王旗。<br>
  吟罢低眉无处写，月光如水照缁衣。</p>
<p>  记得之前在网上看过一段文字，说工具发明的年代判定差别几十年是常有的事，假使几百年后有人写下“今早鲁迅起来，略觉胸闷，拿出手机看到一条新信息：先生，柔石他们遇难了....<br>
晚上鲁迅打开电脑敲下：忍看朋辈成新鬼，怒向刀丛觅小诗”这样的文章也不足为奇。<br>
  哎，深觉有趣，不知百年后别人如何描述我们这个时代，又不知我们描述的百年前时代究竟是什么模样啊。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hypermesh自定义显示角度]]></title>
        <id>https://bronzecraft.github.io/post/Pvc8vn5tc/</id>
        <link href="https://bronzecraft.github.io/post/Pvc8vn5tc/">
        </link>
        <updated>2021-01-24T07:50:15.000Z</updated>
        <content type="html"><![CDATA[<p>  鉴于hypermesh中的齐次旋转矩阵太难定义，本文采用旋转命令进行调整视图角度。<br>
  大约分三步：</p>
<ol>
<li>定义屏幕坐标系；</li>
<li>定义选取面的法向坐标系；</li>
<li>旋转选取面的法向线使之与屏幕法线旋转重合。</li>
</ol>
<p>  由于本人对hypermesh tcl命令不是很熟，所以采用了一个绕圈的方法，实际上hypermesh提供了矢量叉乘功能 。<s>（然而本人太懒不想去搞明白它的用法）</s></p>
<pre><code>#vector cross product function
proc cdot {v1 v2} {
	foreach {x1 y1 z1} [lindex $v1] {}
	foreach {x2 y2 z2} [lindex $v2] {}
	set x3 [expr $y1*$z2 - $z1*$y2];
	set y3 [expr $z1*$x2 - $x1*$z2];
	set z3 [expr $x1*$y2 - $y1*$x2];
	set xyz [expr sqrt($x3*$x3+$y3*$y3+$z3*$z3)]
	return &quot;[expr $x3/$xyz] [expr $y3/$xyz] [expr $z3/$xyz] &quot;;
	}
#vector inner product function
proc dot {v1 v2} {
	foreach {x1 y1 z1} [lindex $v1] {}
	foreach {x2 y2 z2} [lindex $v2] {}
	set x [expr $x1*$x2+$y1*$y2+$z1*$z2]
	return $x
	}
#vector length function
proc absvect {v1} {
	foreach {x1 y1 z1} [lindex $v1] {}
	set t [expr sqrt($x1*$x1+$y1*$y1+$z1*$z1)]
	return $t
	}
# roate the view by using default  point
proc roate_xyz { plane } {
	set pi [expr asin(1)*2]	
	set vect_3 [lindex [lindex $plane 0] 0]
	foreach {x1 y1 z1} [lindex [lindex $plane 0] 1] {}
	set vect_scrn_normal [hm_getscreenvector normal]
	set vect_scrn_parllel [hm_getscreenvector parallel]
	set vect_scrn_z [cdot $vect_scrn_normal $vect_scrn_parllel]
	set th_1 [expr acos([dot $vect_3 $vect_scrn_parllel]/[absvect $vect_3]/[absvect $vect_scrn_parllel])]
	catch {unset$vx}
	for {set i 0} {$i&lt;=2} {incr i} {
		set x [expr [lindex $vect_3 $i] - [lindex $vect_scrn_parllel $i]/[absvect $vect_scrn_parllel]*[absvect $vect_3]*(cos($th_1))]
		lappend vx $x
		}
	set th_2 [expr acos([dot $vx $vect_scrn_normal]/[absvect $vx]/[absvect $vect_scrn_normal])]
	set th1_gr [expr $th_1/$pi*180 - 90]
	set th2_gr [expr $th_2/$pi*180]

	set th_3 [expr acos([dot $vect_3 $vect_scrn_z]/[absvect $vect_3]/[absvect $vect_scrn_z])]

	if { $th_3&gt;[expr $pi/2] } {
		*rotateabout 1 $x1 $y1 $z1
		*rotate 0 -$th2_gr;
		*rotate 90 $th1_gr;
		} else {
		*rotateabout 1 $x1 $y1 $z1
		*rotate 0 $th2_gr;
		*rotate 90 $th1_gr;
		}
	}
# ###################################################################	
set plane [hm_getplanepanel &quot;Please define a plane&quot;]
if {[llength [lindex [lindex $plane 0] 0]]} {
	roate_xyz $plane
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nastran Dmap学习笔记（1）]]></title>
        <id>https://bronzecraft.github.io/post/pO8G2S8TD/</id>
        <link href="https://bronzecraft.github.io/post/pO8G2S8TD/">
        </link>
        <updated>2021-01-19T11:53:08.000Z</updated>
        <content type="html"><![CDATA[<p>一个小例子：</p>
<pre><code>       sol hw
       compile hw
       subdmap hw
       message //' hello world '$
       end
       cend
       begin bulk
       enddata
</code></pre>
<p>.f06文件里可以看到输出&quot;HELLO WORLD &quot;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MSC.Marc求解器简单比较]]></title>
        <id>https://bronzecraft.github.io/post/2soV52Ss7/</id>
        <link href="https://bronzecraft.github.io/post/2soV52Ss7/">
        </link>
        <updated>2021-01-18T13:07:09.000Z</updated>
        <content type="html"><![CDATA[<p>  对Marc求解器算例验证最全的应该是自带帮助文档Vol E的2.79，不过那是基于linear analysis。本文试着拿非线性接触问题简单比较下Marc的求解器，验证一些想法。<br>
  本示例开启了Stress Assembly and Recovery并行和Matrix solver并行，模型中1024个壳单元，240个实体单元。<br>
  采用Multifrontal Sparse Solver，求解过程中最大内存使用为184M。求解时间信息如下：</p>
<pre><code>         timing information:                             wall time      cpu time

           total time for input:                              0.10          0.09
           total time for stiffness matrix assembly:         43.65         86.67
           total time for mass matrix assembly:               0.00          0.00
           total time for stress recovery:                   16.02         31.81
           total time for matrix solution:                   41.01         82.44
           total time for contact:                            0.45          0.72
           total time for output:                             0.23          0.53
           total time for miscellaneous:                     14.96          9.73
           ---------------------------------------------------------------------
           total time:                                      116.42        212.00


         multi-threading overheads:                      wall time      cpu time

           total time for multi-threading:                    0.27          0.22
           (note that this time is also counted
            in other sections)
</code></pre>
<p>  下面是相同模型相同并行设置，采用Pardiso Direct Sparse Solver，求解过程最大使用内存为196M。花费的时间信息如下：</p>
<pre><code>         timing information:                             wall time      cpu time

           total time for input:                              0.09          0.08
           total time for stiffness matrix assembly:         42.18         84.34
           total time for mass matrix assembly:               0.00          0.00
           total time for stress recovery:                   15.87         31.92
           total time for matrix solution:                   53.81        104.97
           total time for contact:                            0.42          1.16
           total time for output:                             0.32          0.62
           total time for miscellaneous:                     18.94         10.91
           ---------------------------------------------------------------------
           total time:                                      131.64        234.00


         multi-threading overheads:                      wall time      cpu time

           total time for multi-threading:                    0.25          0.62
           (note that this time is also counted
            in other sections)
</code></pre>
<p>  相同模型更改为Mumps direct solver，求解过程中最大使用内存为188M，求解时间信息如下：</p>
<pre><code>              timing information:                             wall time      cpu time

           total time for input:                              0.09          0.09
           total time for stiffness matrix assembly:         41.42         81.44
           total time for mass matrix assembly:               0.00          0.00
           total time for stress recovery:                   15.71         31.41
           total time for matrix solution:                   41.92         83.59
           total time for contact:                            0.43          0.91
           total time for output:                             0.29          0.64
           total time for miscellaneous:                     13.47          9.58
           ---------------------------------------------------------------------
           total time:                                      113.33        207.66


         multi-threading overheads:                      wall time      cpu time

           total time for multi-threading:                    0.23          0.64
           (note that this time is also counted
            in other sections)
</code></pre>
<p>  更改成CASI Iterative solver再试算下，最大使用内存为256M，*（不科学，迭代求解器怎么会比直接求解器内存耗费更大，回头我再检查下模型）*求解时间信息如下：</p>
<pre><code>            [本示例中因个人电脑原因最后卡住一段时间导致杂项时间过多，实际应用时间约236.72s]
            timing information:                             wall time      cpu time

           total time for input:                              0.09          0.09
           total time for stiffness matrix assembly:         43.57         87.00
           total time for mass matrix assembly:               0.00          0.00
           total time for stress recovery:                   16.32         32.23
           total time for matrix solution:                  168.21        286.58
           total time for contact:                            0.46          0.91
           total time for output:                             0.30          0.59
           total time for miscellaneous:                    157.01         10.33
           ---------------------------------------------------------------------
           total time:                                      385.95        417.73


         multi-threading overheads:                      wall time      cpu time

           total time for multi-threading:                    0.25          0.34
           (note that this time is also counted
            in other sections)
</code></pre>
<p>  最后采用Multifrontal Sparse Solver，同样设置，只不过Matrix fil Optimization更改为internal，即采用软件自己的矩阵带宽优化功能，最大使用内存为182M。*（我以为Metis会优化带宽减少内存使用量来着）*时间信息如下：（杂项时间过多原因同上）</p>
<pre><code>         timing information:                             wall time      cpu time

           total time for input:                              0.09          0.08
           total time for stiffness matrix assembly:         43.41         86.58
           total time for mass matrix assembly:               0.00          0.00
           total time for stress recovery:                   16.63         33.53
           total time for matrix solution:                   37.38         72.73
           total time for contact:                            0.47          1.12
           total time for output:                             0.28          0.30
           total time for miscellaneous:                    156.75         11.03
           ---------------------------------------------------------------------
           total time:                                      255.01        205.38


         multi-threading overheads:                      wall time      cpu time

           total time for multi-threading:                    0.23          0.30
           (note that this time is also counted
            in other sections)
</code></pre>
<p>  哪天有空开DDM再试算下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://bronzecraft.github.io/post/kxBbXLIIs/</id>
        <link href="https://bronzecraft.github.io/post/kxBbXLIIs/">
        </link>
        <updated>2021-01-14T14:40:03.000Z</updated>
        <content type="html"><![CDATA[<p>本站是一个记录本人随思随想的小角落，嗯....<s>（即便是身处果壳之中也自以为是宇宙之王，并不是）</s><br>
本人只是一个保安 <s>（宇宙尽头的餐馆门口的保安，也太中二了）</s><br>
本人喜欢科幻，历史，机械，编程，徒步，骑行...兴趣较多然而并没有什么深入且擅长的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[热寂脑洞]]></title>
        <id>https://bronzecraft.github.io/post/eKrKUSyd0/</id>
        <link href="https://bronzecraft.github.io/post/eKrKUSyd0/">
        </link>
        <updated>2021-01-14T14:29:45.000Z</updated>
        <content type="html"><![CDATA[<p>这是很久以前就有的脑洞，宇宙或许早就进入了热寂。涨落无处不在，而我们刚好在一个低熵的宇宙洼地，随着时间流逝迎来最后的消亡。<br>
而后又有更进一步脑洞，假定宇宙中有无数的低熵洼地，终归有生命能在熵回升前逃离洼地。<br>
一艘载着流亡者的帆船航行在熵之海上，不停的寻找洼地延续自身，旅途中会遇到各种各样的生命和种群。<br>
再进一步，或许有更多的洼地在消亡前发展到能简单对抗熵回升的趋势，它们派出探索飞船，去探索，去转移，去搜集资源。<br>
再再进一步，有一艘飞船或者洼地认为这样苟延残喘没有意义，决议牺牲自己，点燃宇宙，让熵海沸腾，最后创造一个新宇宙，继而希望宇宙能诞生出永存的生命。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello world]]></title>
        <id>https://bronzecraft.github.io/post/R6szcXDYA/</id>
        <link href="https://bronzecraft.github.io/post/R6szcXDYA/">
        </link>
        <updated>2021-01-14T14:11:56.000Z</updated>
        <content type="html"><![CDATA[<p>折腾了许久，终于将Gridea和Github同步成功不更新的问题解决了。<br>
记录开始！</p>
]]></content>
    </entry>
</feed>