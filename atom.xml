<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bronzecraft.github.io</id>
    <title>迷藏</title>
    <updated>2021-02-11T16:03:14.270Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bronzecraft.github.io"/>
    <link rel="self" href="https://bronzecraft.github.io/atom.xml"/>
    <subtitle>一个宇宙尽头的餐馆门口保安的闲言碎语</subtitle>
    <logo>https://bronzecraft.github.io/images/avatar.png</logo>
    <icon>https://bronzecraft.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 迷藏</rights>
    <entry>
        <title type="html"><![CDATA[春节假期随笔（一）]]></title>
        <id>https://bronzecraft.github.io/post/ZVy9CJA76/</id>
        <link href="https://bronzecraft.github.io/post/ZVy9CJA76/">
        </link>
        <updated>2021-02-11T15:23:31.000Z</updated>
        <content type="html"><![CDATA[<p>  今天是春节法定假日第一天，也是年三十，未能回家，内心赶不走的内疚。<br>
  晚上看了一部老电影，《落叶归根》，颇有感触。电影很好看，赵本山奉献了影帝级别的表演。故事据说是导演根据一位农民工的真实经历改编而成的，想起以前看的《山河故人》，贾樟柯也将一段真实情节化用进了自己的电影——一名僧人在太原火车站候车室超度突然去世的老人。<img src="https://bronzecraft.github.io/post-images/1613057514201.jpg" alt="" loading="lazy"><br>
  《落叶归根》的故事给人一种无奈而又坚持的感觉。抱着完成诺言的朴素想法坚持把工友的尸体送回老家，路上遇到了劫匪、小偷、黑店，被各种欺负，也遇到了情伤的卡车司机、独身一人的老人、正规发廊的打工妹、野外游荡的蜂农。被骗被欺负，也有被帮助，男主角最终把工友送到了老家，然而只剩下一片废墟 ——工友一家可能已经因为三峡水库蓄水搬到别的地方去了。“爸爸我们知道错了，我们找了你很久，我们搬家了，新家在湖北xxxx”，这段留言背后又有怎样的故事啊，令人唏嘘。<br>
  《山河故人》则给我另一种感受，电影像是一个记录者单纯记录时间的推进时代的变迁，女主成婚，离婚，而又老去。我没办法详细表达自己内心的感受。倪匡的卫斯理系列有一个故事是一对可以在时间中旅行的情侣拍摄了历史中曾经发生过的事——一名哥老会打手的人生，他的成长、努力和失败，然后把这段纪录片寄给了卫斯理。《山河故人》就给我这样的感觉，导演好像是单纯从历史中摘取了这样一个人的人生并把它展示出来。顺便说一句，影片中的《go west》插曲也曾被用在另一部电影《有话好好说》，一部喜剧，赵本山在里面出演了一个小角色——收废品的。拿着姜文给的喇叭喊出了那段经典台词：安红俺想你。<br>
  晚上从同学那边回来，看到小区里一名父亲在放小小的烟花，母亲抱着孩子在旁边观看，蛮温馨。想起过去在老家过年，那时还没有禁放烟花炮竹，小孩子们吃完晚饭到处放炮仗，这样的情景以后大抵是见不到了。<br>
  就这样吧，外边的炮声也响起来了，新年了！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[窗前随笔]]></title>
        <id>https://bronzecraft.github.io/post/si14YgKRg/</id>
        <link href="https://bronzecraft.github.io/post/si14YgKRg/">
        </link>
        <updated>2021-02-07T13:33:45.000Z</updated>
        <content type="html"><![CDATA[<p>  闲坐时收到一条系统短信，说明日降温注意保暖云云。想着前面与家里通话我说无锡今日很热而我妈说家里很冷，笑着说明日无锡开始降温，大抵是老家的冷空气跑到我这里了。看到这条短信又引发了一些回忆。<br>
  高中读书时学过一篇课文，余秋雨的《听听那冷雨》，里面提到作者客居台湾，已经二十余年未曾踏上大陆，在寒潮掠过大陆涌向台湾时感叹不能扑进她怀里，被她的裙边扫下也算是安慰孺慕之情。<br>
  今年疫情严重，各地政策变动不定，这个春节是确定回不去老家了。这还是这么大第一次在外地过春节，这几日颇有感触。虽说年味越来越淡，但春节团圆的象征意义依旧在，无法回去陪父母致使心情很是失落。今日被这条系统短信又一次勾起难言之情。我自然不像余先生这般多年未回家，但依然稍微体会到余先生的这种借气候变化抚慰内心思乡之情的心态。<br>
  故乡啊！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python实现多线程写入和读出]]></title>
        <id>https://bronzecraft.github.io/post/Xs9mZGFXm/</id>
        <link href="https://bronzecraft.github.io/post/Xs9mZGFXm/">
        </link>
        <updated>2021-02-06T14:12:04.000Z</updated>
        <content type="html"><![CDATA[<p>   一个简单例子。代码如下：</p>
<pre><code># -*- coding: utf-8 -*-

import threading
import time
import queue
import os
import subprocess

class sharefunc:
    '''
    shared function
    '''
    def __init__(self,initial_value=0):
        # self.value = intial_value
        self.data=initial_value
        self._value_lock = threading.Lock()
        self.tasklist = []
    
    def taskin(self,data):
        for i in range(data):
            with self._value_lock:
                self.tasklist.append(i)
            time.sleep(1)
    
    def taskini(self,data):
        for i in range(data):
            with self._value_lock:
                self.tasklist.append(i+20)
            time.sleep(0.5)
     
        
     
        
    def taskout(self):
        with self._value_lock:
            f = open(&quot;run.bat&quot;,&quot;w&quot;)
            x = self.tasklist[0]
            del self.tasklist[0]
            print ('out number:',x)
            print ('lenth oflist is :',len(self.tasklist))
            # f.write('del *.txt' +&quot;\n&quot;)
            f.write(&quot;ping -n 1 www.bing.com &gt; &quot;+str(x)+&quot;.txt&quot; +&quot;\n&quot;)
            f.write(&quot;ping -n &quot;+str(x)+&quot; www.bing.com &gt;&gt; &quot;+str(x)+&quot;.txt&quot;+&quot;\n&quot;)           
            f.close()
        # print(&quot;1ok&quot;)
        os.system(&quot;run.bat&quot;)
        # print(&quot;2ok&quot;)
        return x
test=[]
t = sharefunc()
t.taskin(2)
# print(t.tasklist[0])
# x = t.taskout()
# print(x)
print(len(t.tasklist))
t1 = threading.Thread(target=t.taskin,args=(9,))
t1.start()
t3 = threading.Thread(target=t.taskini,args=(9,))
t3.start()

# t1.join()
# for i in range(10):
#     print(t1.is_alive())
#     if (not t1.is_alive()):
#         t1 = threading.Thread(target=t.taskin,args=(i+2,))
#         t1.start()
#         print(&quot;t1: &quot;,i)

tx = 1
# for i in t.tasklist:
#     print (i)
while (tx==1):
    # print(&quot;t.taskin thread is &quot;,t1.is_alive())
    if (len(t.tasklist)&gt;0):
        t2 = threading.Thread(target=t.taskout,args=())
        t2.start()
        t2.join()
    if (not t1.is_alive()) and (len(t.tasklist)&lt;1) and(not t1.is_alive()):
        break
        

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于太空漫游四部曲]]></title>
        <id>https://bronzecraft.github.io/post/qt-aecOEz/</id>
        <link href="https://bronzecraft.github.io/post/qt-aecOEz/">
        </link>
        <updated>2021-01-31T12:47:21.000Z</updated>
        <content type="html"><![CDATA[<p>  阿瑟克拉克“太空漫游四部曲”里，我最喜欢第二部。第一部探讨了人类可能的过去以及或许的未来，外星文明接近于神这个概念，整部小说可能哲学上的意义更浓一些。而第二部更进一步揭露外星文明的一角，特别是鲍曼和弗洛伊德见面那段，印象深刻，（至今还记得大卫鲍曼利用浮动的灰尘捏出来的人像只有眼睛最清晰，性别特征基本没有），算是对人类的未来有更深的描述。其后点燃木星这个桥段对于彼时的我来说更显瑰丽与宏大，整部小说在我理解范围内展示了外星技术的高度。后两部外星文明逐渐走下神坛，特别是最后一部，已经从神变成了普通高技术外星文明了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tkinter库学习笔记（1）]]></title>
        <id>https://bronzecraft.github.io/post/a-U-9nWgO/</id>
        <link href="https://bronzecraft.github.io/post/a-U-9nWgO/">
        </link>
        <updated>2021-01-31T11:10:54.000Z</updated>
        <content type="html"><![CDATA[<p>  周末简单看了下Tkinter库的帮助文档，写了一个小程序，记录鼠标点击按钮的次数，代码如下：</p>
<pre><code>import tkinter as tk

top = tk.Tk()
n = 0
def ph():
    global n
    n = n + 1
    lab.configure(text =str(n) )
    return 0
butn =tk.Button(top,text = &quot;click&quot;,command=ph)
lab = tk.Label(top,text = str(n))
lab.pack()
butn.pack()
top.mainloop()
</code></pre>
<p>  原打算使用bind方法实现的，不过暂时没搞懂bind的用法，一直失败。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无题]]></title>
        <id>https://bronzecraft.github.io/post/O-4HYtF7e/</id>
        <link href="https://bronzecraft.github.io/post/O-4HYtF7e/">
        </link>
        <updated>2021-01-25T12:33:50.000Z</updated>
        <content type="html"><![CDATA[<p>  惯于长夜过春时，挈妇将雏鬓有丝。<br>
  忍看朋辈成新鬼，怒向刀丛觅小诗。<br>
  梦里依稀慈母泪，城头变幻大王旗。<br>
  吟罢低眉无处写，月光如水照缁衣。</p>
<p>  记得之前在网上看过一段文字，说工具发明的年代判定差别几十年是常有的事，假使几百年后有人写下“今早鲁迅起来，略觉胸闷，拿出手机看到一条新信息：先生，柔石他们遇难了....<br>
晚上鲁迅打开电脑敲下：忍看朋辈成新鬼，怒向刀丛觅小诗”这样的文章也不足为奇。<br>
  哎，深觉有趣，不知百年后别人如何描述我们这个时代，又不知我们描述的百年前时代究竟是什么模样啊。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hypermesh自定义显示角度]]></title>
        <id>https://bronzecraft.github.io/post/Pvc8vn5tc/</id>
        <link href="https://bronzecraft.github.io/post/Pvc8vn5tc/">
        </link>
        <updated>2021-01-24T07:50:15.000Z</updated>
        <content type="html"><![CDATA[<p>  鉴于hypermesh中的齐次旋转矩阵太难定义，本文采用旋转命令进行调整视图角度。<br>
  大约分三步：</p>
<ol>
<li>定义屏幕坐标系；</li>
<li>定义选取面的法向坐标系；</li>
<li>旋转选取面的法向线使之与屏幕法线旋转重合。</li>
</ol>
<p>  由于本人对hypermesh tcl命令不是很熟，所以采用了一个绕圈的方法，实际上hypermesh提供了矢量叉乘功能 。<s>（然而本人太懒不想去搞明白它的用法）</s></p>
<pre><code>#vector cross product function
proc cdot {v1 v2} {
	foreach {x1 y1 z1} [lindex $v1] {}
	foreach {x2 y2 z2} [lindex $v2] {}
	set x3 [expr $y1*$z2 - $z1*$y2];
	set y3 [expr $z1*$x2 - $x1*$z2];
	set z3 [expr $x1*$y2 - $y1*$x2];
	set xyz [expr sqrt($x3*$x3+$y3*$y3+$z3*$z3)]
	return &quot;[expr $x3/$xyz] [expr $y3/$xyz] [expr $z3/$xyz] &quot;;
	}
#vector inner product function
proc dot {v1 v2} {
	foreach {x1 y1 z1} [lindex $v1] {}
	foreach {x2 y2 z2} [lindex $v2] {}
	set x [expr $x1*$x2+$y1*$y2+$z1*$z2]
	return $x
	}
#vector length function
proc absvect {v1} {
	foreach {x1 y1 z1} [lindex $v1] {}
	set t [expr sqrt($x1*$x1+$y1*$y1+$z1*$z1)]
	return $t
	}
# roate the view by using default  point
proc roate_xyz { plane } {
	set pi [expr asin(1)*2]	
	set vect_3 [lindex [lindex $plane 0] 0]
	foreach {x1 y1 z1} [lindex [lindex $plane 0] 1] {}
	set vect_scrn_normal [hm_getscreenvector normal]
	set vect_scrn_parllel [hm_getscreenvector parallel]
	set vect_scrn_z [cdot $vect_scrn_normal $vect_scrn_parllel]
	set th_1 [expr acos([dot $vect_3 $vect_scrn_parllel]/[absvect $vect_3]/[absvect $vect_scrn_parllel])]
	catch {unset$vx}
	for {set i 0} {$i&lt;=2} {incr i} {
		set x [expr [lindex $vect_3 $i] - [lindex $vect_scrn_parllel $i]/[absvect $vect_scrn_parllel]*[absvect $vect_3]*(cos($th_1))]
		lappend vx $x
		}
	set th_2 [expr acos([dot $vx $vect_scrn_normal]/[absvect $vx]/[absvect $vect_scrn_normal])]
	set th1_gr [expr $th_1/$pi*180 - 90]
	set th2_gr [expr $th_2/$pi*180]

	set th_3 [expr acos([dot $vect_3 $vect_scrn_z]/[absvect $vect_3]/[absvect $vect_scrn_z])]

	if { $th_3&gt;[expr $pi/2] } {
		*rotateabout 1 $x1 $y1 $z1
		*rotate 0 -$th2_gr;
		*rotate 90 $th1_gr;
		} else {
		*rotateabout 1 $x1 $y1 $z1
		*rotate 0 $th2_gr;
		*rotate 90 $th1_gr;
		}
	}
# ###################################################################	
set plane [hm_getplanepanel &quot;Please define a plane&quot;]
if {[llength [lindex [lindex $plane 0] 0]]} {
	roate_xyz $plane
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nastran Dmap学习笔记（1）]]></title>
        <id>https://bronzecraft.github.io/post/pO8G2S8TD/</id>
        <link href="https://bronzecraft.github.io/post/pO8G2S8TD/">
        </link>
        <updated>2021-01-19T11:53:08.000Z</updated>
        <content type="html"><![CDATA[<p>一个小例子：</p>
<pre><code>       sol hw
       compile hw
       subdmap hw
       message //' hello world '$
       end
       cend
       begin bulk
       enddata
</code></pre>
<p>.f06文件里可以看到输出&quot;HELLO WORLD &quot;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MSC.Marc求解器简单比较]]></title>
        <id>https://bronzecraft.github.io/post/2soV52Ss7/</id>
        <link href="https://bronzecraft.github.io/post/2soV52Ss7/">
        </link>
        <updated>2021-01-18T13:07:09.000Z</updated>
        <content type="html"><![CDATA[<p>  对Marc求解器算例验证最全的应该是自带帮助文档Vol E的2.79，不过那是基于linear analysis。本文试着拿非线性接触问题简单比较下Marc的求解器，验证一些想法。<br>
  本示例开启了Stress Assembly and Recovery并行和Matrix solver并行，模型中1024个壳单元，240个实体单元。<br>
  采用Multifrontal Sparse Solver，求解过程中最大内存使用为184M。求解时间信息如下：</p>
<pre><code>         timing information:                             wall time      cpu time

           total time for input:                              0.10          0.09
           total time for stiffness matrix assembly:         43.65         86.67
           total time for mass matrix assembly:               0.00          0.00
           total time for stress recovery:                   16.02         31.81
           total time for matrix solution:                   41.01         82.44
           total time for contact:                            0.45          0.72
           total time for output:                             0.23          0.53
           total time for miscellaneous:                     14.96          9.73
           ---------------------------------------------------------------------
           total time:                                      116.42        212.00


         multi-threading overheads:                      wall time      cpu time

           total time for multi-threading:                    0.27          0.22
           (note that this time is also counted
            in other sections)
</code></pre>
<p>  下面是相同模型相同并行设置，采用Pardiso Direct Sparse Solver，求解过程最大使用内存为196M。花费的时间信息如下：</p>
<pre><code>         timing information:                             wall time      cpu time

           total time for input:                              0.09          0.08
           total time for stiffness matrix assembly:         42.18         84.34
           total time for mass matrix assembly:               0.00          0.00
           total time for stress recovery:                   15.87         31.92
           total time for matrix solution:                   53.81        104.97
           total time for contact:                            0.42          1.16
           total time for output:                             0.32          0.62
           total time for miscellaneous:                     18.94         10.91
           ---------------------------------------------------------------------
           total time:                                      131.64        234.00


         multi-threading overheads:                      wall time      cpu time

           total time for multi-threading:                    0.25          0.62
           (note that this time is also counted
            in other sections)
</code></pre>
<p>  相同模型更改为Mumps direct solver，求解过程中最大使用内存为188M，求解时间信息如下：</p>
<pre><code>              timing information:                             wall time      cpu time

           total time for input:                              0.09          0.09
           total time for stiffness matrix assembly:         41.42         81.44
           total time for mass matrix assembly:               0.00          0.00
           total time for stress recovery:                   15.71         31.41
           total time for matrix solution:                   41.92         83.59
           total time for contact:                            0.43          0.91
           total time for output:                             0.29          0.64
           total time for miscellaneous:                     13.47          9.58
           ---------------------------------------------------------------------
           total time:                                      113.33        207.66


         multi-threading overheads:                      wall time      cpu time

           total time for multi-threading:                    0.23          0.64
           (note that this time is also counted
            in other sections)
</code></pre>
<p>  更改成CASI Iterative solver再试算下，最大使用内存为256M，*（不科学，迭代求解器怎么会比直接求解器内存耗费更大，回头我再检查下模型）*求解时间信息如下：</p>
<pre><code>            [本示例中因个人电脑原因最后卡住一段时间导致杂项时间过多，实际应用时间约236.72s]
            timing information:                             wall time      cpu time

           total time for input:                              0.09          0.09
           total time for stiffness matrix assembly:         43.57         87.00
           total time for mass matrix assembly:               0.00          0.00
           total time for stress recovery:                   16.32         32.23
           total time for matrix solution:                  168.21        286.58
           total time for contact:                            0.46          0.91
           total time for output:                             0.30          0.59
           total time for miscellaneous:                    157.01         10.33
           ---------------------------------------------------------------------
           total time:                                      385.95        417.73


         multi-threading overheads:                      wall time      cpu time

           total time for multi-threading:                    0.25          0.34
           (note that this time is also counted
            in other sections)
</code></pre>
<p>  最后采用Multifrontal Sparse Solver，同样设置，只不过Matrix fil Optimization更改为internal，即采用软件自己的矩阵带宽优化功能，最大使用内存为182M。*（我以为Metis会优化带宽减少内存使用量来着）*时间信息如下：（杂项时间过多原因同上）</p>
<pre><code>         timing information:                             wall time      cpu time

           total time for input:                              0.09          0.08
           total time for stiffness matrix assembly:         43.41         86.58
           total time for mass matrix assembly:               0.00          0.00
           total time for stress recovery:                   16.63         33.53
           total time for matrix solution:                   37.38         72.73
           total time for contact:                            0.47          1.12
           total time for output:                             0.28          0.30
           total time for miscellaneous:                    156.75         11.03
           ---------------------------------------------------------------------
           total time:                                      255.01        205.38


         multi-threading overheads:                      wall time      cpu time

           total time for multi-threading:                    0.23          0.30
           (note that this time is also counted
            in other sections)
</code></pre>
<p>  哪天有空开DDM再试算下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://bronzecraft.github.io/post/kxBbXLIIs/</id>
        <link href="https://bronzecraft.github.io/post/kxBbXLIIs/">
        </link>
        <updated>2021-01-14T14:40:03.000Z</updated>
        <content type="html"><![CDATA[<p>本站是一个记录本人随思随想的小角落，嗯....<s>（即便是身处果壳之中也自以为是宇宙之王，并不是）</s><br>
本人只是一个保安 <s>（宇宙尽头的餐馆门口的保安，也太中二了）</s><br>
本人喜欢科幻，历史，机械，编程，徒步，骑行...兴趣较多然而并没有什么深入且擅长的。</p>
]]></content>
    </entry>
</feed>